---
title: Rendering Extensions
cobeMode: static
---


# Making a Rendering Extension

The docsite allows for markdown code blocks to be rendered to HTML in an interactive state.  This means a user can edit the code and then see the results of those edits live in the browser.  

A given block could be written in js, vue, react, etc., of course, so we have to tell ACID how to handle the language-type in order to be able to dynamically compile and render components.

We do this via the `cobe` settings.

```js:static
cobe:
[
    { types: [ 'js', 'jsx' ], use: [ 'render-ext', [ 10, true ] ], mode: 'static' }
]
```

In the above example, we have an import name that specifies the use of the **render-ext** module to render content for js and jsx language-type code blocks in the docsite.

> Remember that all this runs in the browser, so the module specified by `use` must be browser accessible (generally, via importmap) as it will be dynamically imported.

The imported module must `export default` a function of the form

```js
function (param: any, lang: string): { render: function }
```

When the docsite loads in the browser, this function will be called once for each of the language `types` it is to be associated with (`lang` parameter), along with the configuration parameter (`param`), if provided.

Here is the general idea from the docsite's perspective:

```js
import renderConfig from 'render-ext'

let { render: jsRender } = renderConfig([ 10, true ], 'js');
let { render: jsxRender } = renderConfig([ 10, true ], 'jsx');
```

The `render` function should have the form:

```js
async function (params: object): void
```

It is called every time a code block with the associated lang marker needs to be rendered.  The `params` argument will contain the following:

- `source` *string*: raw content from the code block
- `imports` *string*: import statements to be added to the code
- `el` *object*: DOM node for mounting the component

The render function should generally do the following:

1. Modify `source` to construct the proper component export for the framework supported.
2. Insert `imports` into the source to make imported names accessible to the code.
3. Perform some sort of build step to generate a component from `source`.
4. Mount the component to `el`.

Here's a pseudocode-ish example of a render function.

```js
// Remember: Module specifiers must be mapped and available in the browser
import Framework from 'supported-component-framework';
import transform from './transform-source-into-component.js';

let render = ({ source, imports, el }) =>
{
    return new Promise((accept, reject) => 
    {
        try
        {
            // #1
            source = transform(source);
            // #2
            source = imports + source;
            // #3 - using a data url to "modulize" the source
            let { default: Component } = await import(`data:text/javascript,${encodeURIComponent(source)}`);
            // #4
            Framework.mount(Component, el);

            accept();
        }
        catch (error)
        {
            reject(error);
        }
    });
}
```

Promise rejections in the rendering process will be caught and displayed to the user.


# Built-in Svelte Renderer

As ACID is built on Svelte, a dynamic component renderer is included out-of-the-box (makes sense, right?).

It is available as a module named "svelte-render".

In your *acid.config.js* file... you can do:

```js
cobe:
[
    { types: [ 'svelte', 'svt' ], use: 'svelte-render', mode: 'edit' }
]
```

Note the example also adds a shorthand "svt" for the code block language-type (save a few keystrokes).  The renderer supports `imports` here as well.

You will also need to tell ACID to build the Svelte renderer, as it is not generated by default.

```js
cobeSvelte: true
```

There is no default HighlightJs syntax highlighting for svelte, so you may wish to alias it (jsx is probably the closest).

```js
hljs: 
{ 
    aliases: { jsx: [ "svelte", "svt"] }
}
```

In a markdown code block, you can write a .svelte file as normal (`<style>` blocks are not supported).

````md
```svelte
<h1 {onclick}> Hello there, { bool ? 'Mark' : 'Fred' }! </h1>

<script>
let bool = $state(false);
let onclick = () => bool = !bool
</script>
```
````

Or, you can use the code/template split style.

````md
```svelte
let bool = $state(false);
let onclick = () => bool = !bool
<h1 {onclick}> Hello there, { bool ? 'Mark' : 'Fred' }! </h1>
```
````

The split form simply requires that the block opens with any JS code at the top followed by an HTML template.

If the `imports` option is used the renderer will append a `<script module>` block.
