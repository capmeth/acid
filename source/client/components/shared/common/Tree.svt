<!--*
    Generates section/asset link tree for a section and its sub-sections.

    When not specified, `section` defaults to the configured `rootSection`.

    When `group` is specified, nothing is rendered if `section` has no child or
    descendant assets in the group. Descendant sections will also be omitted 
    for not having the same.  If `group` is not specified, the full descendant 
    tree from `section` is rendered without assets.

    @tags conditional, delegate

    @property { snippet } each
      Passed each section and asset for render.
    @property { string } [group]
      Asset group to render the tree for.
    @property { string | object } [section]
      The section to be rendered.
    @property { string } [type='tree']
      A type for the internal **List** components.
    @property { snippet } [use]
      Passed a snippet that renders the content of this component.
-->

<When {test} {use}>
  {@render listAssets(section[group])}
  {@render listSections(section.sections)}  
</When>

{#snippet listSections(items)}
  <List {items} {filter} pred={sinfo} {type}>
    {#snippet children(sect)}
      {@render each(sect, 'section')}
      {@render listAssets(sect[group])}
      {@render listSections(sect.sections)}
    {/snippet}
  </List>  
{/snippet}

{#snippet listAssets(items)}
  {#if !isSections}
    <List {items} pred={ainfo} {type}>
      {#snippet children(asset)}
        {@render each(asset, asset.type)}
      {/snippet}
    </List>
  {/if}
{/snippet}


<script module>
import { ainfo, sinfo } from '#frend/lib'

import List from './List'
import When from './When'
</script>

<script>
let { each, group, section, type = 'tree', use } = $props();

group ||= 'sections';
section = section ? sinfo(section) : sinfo.root;

let hasAssets = section => !!section[group]?.length || !!section.descendants[group]?.length

let isSections = group === 'sections';
let test = isSections ? !!section.sections?.length : hasAssets(section);

let filter = sect => isSections || hasAssets(sinfo(sect))
</script>
