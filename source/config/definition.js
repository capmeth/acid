
let test =
{
    alphanum: h => h.re(/^[a-z0-9_-]+$/) || h.err('must be alphanumeric (including `_` and `-` characters)'),
    arrayOrObject: h => h.object ? h.toArray() : h.err('must be an array or an object'),
    arrayOrObjectOrString: h => h.or(h.string, h.plain, h.array) ? h.toArray() : 
        h.err('must be an array, object, or a string'),
    arrayOrString: h => h.or(h.string, h.array) ? h.toArray() : h.err('must be an array or a string'),
    arrayOrStringOrNull: h => h.or(h.null, h.string, h.array) ? h.toArray() : 
        h.err('must be an array, a string, or null'),
    boolean: h => h.bool || h.err('must be set to true or false'),
    cobeMode: h => h.in('edit', 'live', 'render', 'static') || h.err('must be a valid enumerated value'),
    display: h => h.in('always-hide', 'hide', 'always-show', 'show') || h.err('must be a valid enumerated value'),
    functionOrNull: h => h.or(h.null, h.func) || h.err('must be a function or null'),
    functionOrArrayOrNull: h => h.or(h.null, h.func, h.array) || h.err('must be a function or an array or null'),
    functionOrArrayOrStringOrNull: h => h.or(h.null, h.func, h.string, h.array) || 
        h.err('must be a function or an array or a string or null'),
    zeroPlus: h => h.and(h.number, h.gte(0)) || h.err('must be zero or more'),
    logLevel: h => h.in('fail', 'info', 'off', 'warn', 'test') || h.err('must be a valid enumerated value'),
    objectOrArrayOrString: (...args) => h => h.or(h.string, h.array, h.plain) ? h.toPlain(...args) : 
        h.err('must be an object, array, or a string'),
    objectOrNumber: (...args) => h => h.or(h.number, h.plain) ? h.toPlain(...args) : 
        h.err('must be an object or a number'),
    objectOrString: (...args) => h => h.or(h.string, h.plain) ? h.toPlain(...args) : 
        h.err('must be an object or a string'),
    number: h => h.number || h.err('must be an number'),
    object: h => h.plain || h.err('must be an object'),
    port: h => h.and(!h.lt(0), !h.gt(65535)) || h.err('must be a valid port number'),
    reflags: h => h.or(h.re(/^[dgimsuvy]*$/), h.in(true)) || 
        h.err('must be `true` or contain only regular expression flags'),
    serial: h => h.serial || h.err('must be of serializable type'),
    storage: h => h.in('local', 'session', 'none') || h.err('must be a valid enumerated value'),
    string: h => h.string || h.err('must be a string'),
    stringOrFunction: h => h.or(h.string, h.func) || h.err('must be a string or a function'),
    stringOrNull: h => h.or(h.string, h.null) || h.err('must be a string or null'),
    stringOrObject: h => h.or(h.string, h.plain) || h.err('must be a string or an object'),
    regexOrArrayOrString: h => h.or(h.of(RegExp), h.string, h.array) || 
        h.err('must be a regular expression, string, or an array'),
    unset: h => h.undef || h.err('is not a valid config option')
}

export default
{
    'config': { test: test.object, default: {}, merge: true },
    'config.*': test.unset,
    'config.assetGroups': { test: test.arrayOrString, default: [] },
    'config.assetGroups.*': test.string,
    'config.cobe': { test: test.object, default: {}, merge: true },
    'config.cobe.*': test.unset,

    'config.cobe.code': test.display,

    'config.cobe.noHide': test.boolean,
    'config.cobe.noHighlight': test.boolean,
    'config.cobeSpecs': { test: test.arrayOrObject, default: [] },
    'config.cobeSpecs.*': test.object,
    'config.cobeSpecs.*.*': test.unset,
    'config.cobeSpecs.*.mode': test.cobeMode,
    'config.cobeSpecs.*.noHide': test.boolean,
    'config.cobeSpecs.*.noHighlight': test.boolean,
    'config.cobeSpecs.*.types': { test: test.arrayOrString, default: [] },
    'config.cobeSpecs.*.types.*': test.string,
    'config.cobeSpecs.*.use': test.arrayOrStringOrNull,
    'config.cobeSpecs.*.use.0': test.string,    
    'config.cobeSpecs.*.use.1': test.serial,
    'config.copy': { test: test.arrayOrObject, default: [] },
    'config.copy.*': test.object,
    'config.copy.*.files': { test: test.objectOrArrayOrString('include'), default: {} },
    'config.copy.*.files.*': test.unset,
    'config.copy.*.files.include': { test: test.arrayOrString, default: [] },
    'config.copy.*.files.exclude': { test: test.arrayOrString, default: [] },
    'config.copy.*.to': test.functionOrArrayOrStringOrNull,
    'config.copy.*.to.*': test.unset,
    'config.copy.*.to.0': test.regexOrArrayOrString,
    'config.copy.*.to.1': test.stringOrFunction,    
    'config.hljs': { test: test.object, default: {}, merge: true },
    'config.hljs.*': test.unset,
    'config.hljs.aliases': { test: test.object, default: {}, merge: true },
    'config.hljs.aliases.*': test.arrayOrString,
    'config.hljs.aliases.*.*': test.string,
    'config.hljs.languages': { test: test.arrayOrString, default: [] },
    'config.hljs.languages.*': test.string,
    'config.hljs.theme': test.string,
    'config.hljs.version': test.string,
    'config.httpServer': test.boolean,  
    'config.httpServerPort': test.port,
    'config.importMap': { test: test.object, default: {} }, 
    'config.importMap.imports': test.object, 
    'config.importMap.integrity': test.object, 
    'config.importMap.scopes': test.object, 
    'config.labels': { test: test.object, default: {}, merge: true },
    'config.labels.*': test.string,
    'config.links': { test: test.arrayOrObjectOrString, default: [] },
    'config.links.*': test.objectOrString('href', { rel: 'stylesheet' }),
    'config.logger': { test: test.objectOrString('level'), default: {}, merge: true },
    'config.logger.*': test.unset,
    'config.logger.default': test.functionOrNull,
    'config.logger.fail': test.functionOrNull,
    'config.logger.info': test.functionOrNull,
    'config.logger.level': test.logLevel,
    'config.logger.noChalk': test.boolean,
    'config.logger.test': test.functionOrNull,
    'config.logger.warn': test.functionOrNull,
    'config.metas': { test: test.arrayOrObject, default: [] },
    'config.metas.*': test.object,
    'config.namespace': test.alphanum,
    'config.outputDir': test.string,
    'config.parsers': { test: test.arrayOrObject, default: [] },
    'config.parsers.*': test.object,
    'config.parsers.*.*': test.unset,
    'config.parsers.*.exts': { test: test.arrayOrString, default: [] },
    'config.parsers.*.exts.*': test.string,
    'config.parsers.*.use': test.arrayOrStringOrNull,
    'config.parsers.*.use.0': test.string,
    'config.parsers.*.use.1': test.serial,
    'config.root': test.string,
    'config.rootSection': test.string,
    'config.scripts': { test: test.arrayOrObjectOrString, default: [] },
    'config.scripts.*': h => h.or(h.string, h.plain) ? h.toPlain('src') : h.err('must be a string or an object'),
    'config.sections': { test: test.object, default: {} },
    'config.sections.*': test.object,
    'config.sections.*.components': { test: test.objectOrArrayOrString('include'), default: {} },
    'config.sections.*.components.*': test.unset,
    'config.sections.*.components.include': { test: test.arrayOrString, default: [] },
    'config.sections.*.components.exclude': { test: test.arrayOrString, default: [] },
    'config.sections.*.documents': { test: test.objectOrArrayOrString('include'), default: {} },
    'config.sections.*.documents.*': test.unset,
    'config.sections.*.documents.include': { test: test.arrayOrString, default: [] },
    'config.sections.*.documents.exclude': { test: test.arrayOrString, default: [] },
    'config.sections.*.overview': test.string,
    'config.sections.*.sections': { test: test.arrayOrString, default: [] },
    'config.sections.*.sections.*': test.string,
    'config.sections.*.title': test.string,
    'config.socket': { test: test.objectOrNumber('port'), default: {}, merge: true },
    'config.socket.*': test.unset,
    'config.socket.port': test.port,
    'config.socket.recoAttempts': test.zeroPlus,
    'config.socket.recoAttemptDelay': test.zeroPlus,
    'config.storage': test.storage,
    'config.style': { test: test.objectOrArrayOrString('sheets'), default: {} },
    'config.style.merge': test.boolean,
    'config.style.sheets': { test: test.arrayOrString, default: [] },
    'config.style.sheets.*': test.string,
    'config.tagLegend': { test: test.object, default: {} },
    'config.tagLegend.*': test.objectOrString('desc'),
    'config.tagLegend.*.*': test.unset,
    'config.tagLegend.*.desc': test.string,
    'config.title': test.string,
    'config.tocDepth': h => h.and(h.number, h.gte(0), h.lte(6)) || h.err('must be a number between 0 and 6'),
    'config.toExampleFile': test.functionOrArrayOrNull,
    'config.toExampleFile.*': test.unset,
    'config.toExampleFile.0': test.regexOrArrayOrString,
    'config.toExampleFile.1': test.stringOrFunction,
    'config.useFilenameOnly': test.boolean,
    'config.version': test.stringOrNull,
    'config.watch': { test: test.object, default: {}, merge: true },
    'config.watch.*': test.unset,
    'config.watch.enabled': test.boolean,
    'config.watch.delay': test.number,
    'config.watch.files': { test: test.objectOrArrayOrString('include'), default: {}, merge: true },
    'config.watch.files.*': test.unset,
    'config.watch.files.include': { test: test.arrayOrString, default: [] },
    'config.watch.files.exclude': { test: test.arrayOrString, default: [] }
}
